
Code from the hw assignment that this project is based on.


#include <fstream>

class Inventory {
    private:
        // binary file
        std::fstream* inv;
        std::string file_name;
        static const std::string default_file_name;

        // helper functions
        void incCount();
        void decCount();
        char getStatus(int);
        bool atEOF(std::fstream*, int);
        void moveWritePointer(std::fstream*, int, long long);
        void moveReadPointer(std::fstream*, int, long long);
        bool verifyBinary(char[4]);
        bool writeItem(int, Item*, std::fstream*);
        void cleanFile();

};

Inventory::Inventory(std::string f_name) {
    // set file name
    file_name = f_name;

    // attempt to open file
    inv = new std::fstream{file_name, std::ios::binary | std::ios::in | std::ios::out};

    // if file not opened (doesn't exist), use ofstream to create one with same name
    // then close ofstream, open file as fstream, and initFile to initialize the counter to 0
    if (!*inv) {
        delete inv;
        std::ofstream* temp_stream = new std::ofstream(file_name);
        temp_stream->close();
        // delete temp_stream;
        inv = new std::fstream{file_name, std::ios::binary | std::ios::in | std::ios::out};
        initFile(inv);
    } else {
        readHeader();
    }

    // set flags
    bool size_offset_initialized = false;
    bool has_deleted_items = false;
}

Inventory::~Inventory() {
    inv->sync();
    if (has_deleted_items) { cleanFile(); }
    inv->sync();
    inv->close();
    delete inv;
}

// initialize a new binary file
void Inventory::initFile(std::fstream* file) {

    if (!size_offset_initialized) {
        // initialize header size
        header_size = sizeof(int) + sizeof(char) * 11;

        // initialize Item field sizes
        stat_size = sizeof(char);
        desc_size = sizeof(char) * Item::getDescriptionLength();
        quant_size = sizeof(int);
        whole_size = sizeof(double);
        sale_size = sizeof(double);
        date_size = sizeof(Date);

        // calculate item size
        item_size = stat_size + desc_size + quant_size + whole_size + sale_size + date_size;

        // initialize header offset
        header_offset = (long long) header_size;

        // initialize count offset
        count_offset = (long long) sizeof(char) * 5;

        // initialize Item field offsets
        item_offset = 0LL;
        stat_offset = 0LL;
        desc_offset = stat_size;
        quant_offset = desc_offset + desc_size;
        whole_offset = quant_offset + quant_size;
        sale_offset = whole_offset + whole_size;
        date_offset = sale_offset + sale_size;
        eof_offset = date_offset + date_size;

        // initialize count to 0
        count = 0;
    }

    /* write header data to binary file */
    file->seekp(0LL, std::ios::beg);
    // write header id to header
    file->write(reinterpret_cast<char*>(bin_id), sizeof(char) * 3);
    // write inventory version to header
    file->write(reinterpret_cast<char*>(&inv_version), sizeof(char));
    // write header size to header
    file->write(reinterpret_cast<char*>(&header_size), sizeof(char));
    // write count to header
    file->write(reinterpret_cast<char*>(&count), sizeof(int));
    // write status size to header
    file->write(reinterpret_cast<char*>(&stat_size), sizeof(char));
    // write description size to header
    file->write(reinterpret_cast<char*>(&desc_size), sizeof(char));
    // write quantity size to header
    file->write(reinterpret_cast<char*>(&quant_size), sizeof(char));
    // write wholesale price to header
    file->write(reinterpret_cast<char*>(&whole_size), sizeof(char));
    // write sale price to header
    file->write(reinterpret_cast<char*>(&sale_size), sizeof(char));
    // write date to header
    file->write(reinterpret_cast<char*>(&date_size), sizeof(char));
    // sync stream buffer
    file->sync();

    // set size offset flag
    if (!size_offset_initialized) { size_offset_initialized = true; }
}

// read header info to initialize size and offset variables
void Inventory::readHeader() {
    // read header id and version number from header
    char bin_id[4];
    inv->seekg(0LL, std::ios::beg);
    inv->read(reinterpret_cast<char*>(bin_id), sizeof(char) * 4);

    // if wrong header id or version number, create a new binary
    if (!verifyBinary(bin_id)) {
        std::cout << "database error\n";
        inv->close();
        delete inv;
        exit(1);
    }
    // else read the rest of the header

    inv->seekg(4L, std::ios::beg);
    // read header size to header
    inv->read(reinterpret_cast<char*>(&header_size), sizeof(char));
    // read count from header
    inv->read(reinterpret_cast<char*>(&count), sizeof(int));
    // read status size from header
    inv->read(reinterpret_cast<char*>(&stat_size), sizeof(char));
    // read description size from header
    inv->read(reinterpret_cast<char*>(&desc_size), sizeof(char));
    // read quantity size from header
    inv->read(reinterpret_cast<char*>(&quant_size), sizeof(char));
    // read wholesale price from header
    inv->read(reinterpret_cast<char*>(&whole_size), sizeof(char));
    // read sale price from header
    inv->read(reinterpret_cast<char*>(&sale_size), sizeof(char));
    // read date from header
    inv->read(reinterpret_cast<char*>(&date_size), sizeof(char));

    // calculate item size
    item_size = stat_size + desc_size + quant_size + whole_size + sale_size + date_size;

    // initialize header offset
    header_offset = (long long) header_size;

    // initialize count offset
    count_offset = (long long) sizeof(char) * 5;

    // initialize Item field offsets
    item_offset = 0LL;
    stat_offset = 0LL;
    desc_offset = stat_size;
    quant_offset = desc_offset + desc_size;
    whole_offset = quant_offset + quant_size;
    sale_offset = whole_offset + whole_size;
    date_offset = sale_offset + sale_size;
    eof_offset = date_offset + date_size;

    // set size offset flag
    if (!size_offset_initialized) { size_offset_initialized = true; }
}

// return true if at EOF (status = -1)
bool Inventory::atEOF(std::fstream* file, int index) {
    moveReadPointer(file, index, eof_offset);
    char status;
    inv->read(reinterpret_cast<char*>(&status), stat_size);
    return status == -1;
}

// helper function to move write pointer by index
void Inventory::moveWritePointer(std::fstream* file, int index, long long field_offset) {
    // move the read counter to the appropriate byte of the file
    // using the index and offset constants to calculate the correct byte
    file->seekp(header_offset + (item_size * index) + field_offset, std::ios::beg);
}

// helper function to move read pointer by index
void Inventory::moveReadPointer(std::fstream* file, int index, long long field_offset) {
    // move the write counter to the appropriate byte of the file
    // using the index and offset constants to calculate the correct byte
    file->seekg(header_offset + (item_size * index) + field_offset, std::ios::beg);
}

bool Inventory::writeItem(int index, Item* new_item, std::fstream* file) {
    char status = 0;
    char desc[Item::getDescriptionLength()];
    std::string desc_str = new_item->getDescription();
    strcpy(desc, desc_str.c_str());
    int quant = new_item->getQuantity();
    double whole = new_item->getWholesale();
    double sale = new_item->getSalePrice();
    Date* date = new_item->getDate();

    for (int i = desc_str.length(); i < Item::getDescriptionLength(); i++) {
        desc[i] = 0;
    }

    // write item fields
    moveWritePointer(file, index, item_offset);
    file->write(reinterpret_cast<char*>(&status), stat_size);
    file->write(reinterpret_cast<char*>(desc), desc_size);
    file->write(reinterpret_cast<char*>(&quant), quant_size);
    file->write(reinterpret_cast<char*>(&whole), whole_size);
    file->write(reinterpret_cast<char*>(&sale), sale_size);
    file->write(reinterpret_cast<char*>(date), date_size);

    if (index == count) {
        char eof_status = -1;
        file->write(reinterpret_cast<char*>(&eof_status), stat_size);
    }

    file->sync();

    return true;
}

// DEBUG print file header contents without re-reading
void Inventory::printDebug() {
    printf("  DEBUG INFO\n\n");
    printf("  %-12s: %s\n", "File name", file_name.c_str());
    printf("  %-12s: %s\n", "Binary ID", (bin_id + '\0'));
    printf("  %-12s: %d\n", "Version", inv_version);
    printf("  %-12s: %d\n", "Header size", header_size);
    printf("  %-12s: %d\n", "Item count", count);
    printf("  %-12s: %d\n", "Status size", stat_size);
    printf("  %-12s: %d\n", "Desc size", desc_size);
    printf("  %-12s: %d\n", "Quant size", quant_size);
    printf("  %-12s: %d\n", "Whole size", whole_size);
    printf("  %-12s: %d\n", "Sale size", sale_size);
    printf("  %-12s: %d\n", "Date size", date_size);
    printf("  %-12s: %s\n", "Size/offset", (size_offset_initialized == true ? "true" : "false"));
    printf("  %-12s: %s\n", "Has deleted", (has_deleted_items == true ? "true" : "false"));
}






        bool seekItem(int index);
        bool writeItem(Item *item);


        void moveWritePointer(long offset);
        void skipWritePointer(long offset);
        void moveReadPointer(long offset);
        void skipReadPointer(long offset);
        void write(void *bytes, int size);
        void write(const char *str, int len);
        void read(void *bytes, int size);
        void read(const char *str, int len);


//  seekItem
//
//  Iterates through chunks until an undeleted item chunk matching the
//  provided index is found. Sets curr_type, curr_size, curr_status, and
//  curr_item_offset to the type, size, status, and offset of the last
//  item found. If item found at index, returns true; otherwise returns false.
//
//  @param index item index to search for
//  @return true if found, false otherwise
bool InvFile::seekItem(int index) {

    bool item_found = false;

    // seek to beginning of item chunks and set current item offset
    moveReadPointer(item_beg_offset);
    curr_item_offset = item_beg_offset;

    for (int i = 0; i <= index; ++i) {
        // set current index
        curr_index = i;

        // read chunk header
        read(&curr_type, sizeof(ChunkHeader::type));
        read(&curr_size, sizeof(ChunkHeader::size));

        // check chunk type
        if (curr_type == ChunkType::eof) {  // return false if at eof
            item_found = false;
            break;
        } else if (curr_type != ChunkType::item) {  // ignore non-item chunks
            --i;
            // seek to next chunk
            skipReadPointer(curr_size);
            // increase current item offset
            curr_item_offset += sizeof(ChunkHeader) + curr_size;
            continue;
        } else {    // valid item
            // check item status
            read(&curr_status, sizeof(Item::status));
            if (curr_status == ItemFlag::del)
                --i;   // ignore deleted items
        } // end if

        // check if at correct index
        if (i != index) {
            // seek to next chunk
            skipReadPointer(curr_size - sizeof(Item::status));
            // increase current item offset
            curr_item_offset += sizeof(ChunkHeader) + curr_size;
        } else if (i == index) {
            item_found = true;
            break;
        } // end if
    } // end for

    return item_found;
} // end InvFile::seekItem

// write item at current index
bool InvFile::writeItem(Item *item) {

    // write Chunk header
    ChunkHeader new_header(ChunkType::item, item->getSize());
    moveWritePointer(curr_item_offset);
    write(&new_header.type, sizeof(ChunkHeader::type));
    write(&new_header.size, sizeof(ChunkHeader::size));

    // set item status to not open
    item->status ^= ItemFlag::open;

    // write item
    write(&item->status, sizeof(Item::status));
    write(&item->quant, sizeof(Item::quant));
    write(&item->sale_adj, sizeof(Item::sale_adj));
    write(&item->sale, sizeof(Item::sale));
    write(&item->whole, sizeof(Item::whole));
    write(&item->date, sizeof(Item::date));
    write(&item->desc_len, sizeof(Item::desc_len));
    write(item->desc, item->desc_len);

    // update EOF if at end of file
    if (curr_index == item_count) {
        eof_offset += curr_size;
        updateEOF();
    }

    // update summary
    updateSummary(item);

    return true;
}

// move write pointer to offset
inline void InvFile::moveWritePointer(long offset) {
    inv->seekp(offset, std::ios::beg);
}

// skip write pointer ahead by offset
inline void InvFile::skipWritePointer(long offset) {
    inv->seekp(offset, std::ios::cur);
}

// move read pointer to offset
inline void InvFile::moveReadPointer(long offset) {
    inv->seekg(offset, std::ios::beg);
}

// skip read pointer ahead by offset
inline void InvFile::skipReadPointer(long offset) {
    inv->seekg(offset, std::ios::cur);
}

// write data to file
inline void InvFile::write(void *data, int size){
    inv->write(reinterpret_cast<char*>(data), size);
}

// write string to file
inline void InvFile::write(const char *str, int len) {
    inv->write(str, sizeof(char) * len);
}

// read data to file
inline void InvFile::read(void *data, int size) {
    inv->read(reinterpret_cast<char*>(data), size);
}

// read string from file
inline void InvFile::read(const char *str, int len) {
    inv->read(const_cast<char*>(str), len);
}



